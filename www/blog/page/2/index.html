<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>双能卫</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="双能卫">
<meta property="og:url" content="http://www.libcz.com/blog/page/2/index.html">
<meta property="og:site_name" content="双能卫">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="双能卫">
  
    <link rel="alternative" href="/blog/atom.xml" title="双能卫" type="application/atom+xml">
  
  
    <link rel="icon" href="http://images.libcz.com:8000/images/favicon.png">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/blog" class="profilepic">
			
			<img lazy-src="http://images.libcz.com:8000/images/white_bg_logo.png" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/blog">C Z</a></h1>
		</hgroup>

		
		<p class="header-subtitle">双能卫</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
							<li><a href="http://www.libcz.com/about.html">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="jianshu_ios" target="_blank" href="http://www.jianshu.com/users/b8b64af5b6f9/timeline" title="jianshu_ios">jianshu_ios</a>
					        
								<a class="github" target="_blank" href="http://github.com/cz-it" title="github">github</a>
					        
								<a class="jianshu_golang" target="_blank" href="http://www.jianshu.com/users/86f2f6a5968e/timeline" title="jianshu_golang">jianshu_golang</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/CocoaPods/" style="font-size: 10px;">CocoaPods</a> <a href="/blog/tags/JSON/" style="font-size: 10px;">JSON</a> <a href="/blog/tags/NATS/" style="font-size: 10px;">NATS</a> <a href="/blog/tags/NSJSONSerialization/" style="font-size: 10px;">NSJSONSerialization</a> <a href="/blog/tags/Ono/" style="font-size: 10px;">Ono</a> <a href="/blog/tags/Realm/" style="font-size: 10px;">Realm</a> <a href="/blog/tags/Reaml/" style="font-size: 13.33px;">Reaml</a> <a href="/blog/tags/ReplayKit/" style="font-size: 10px;">ReplayKit</a> <a href="/blog/tags/UIStackView/" style="font-size: 10px;">UIStackView</a> <a href="/blog/tags/Xcode/" style="font-size: 10px;">Xcode</a> <a href="/blog/tags/autolayout/" style="font-size: 10px;">autolayout</a> <a href="/blog/tags/cli/" style="font-size: 10px;">cli</a> <a href="/blog/tags/gRPC/" style="font-size: 10px;">gRPC</a> <a href="/blog/tags/gnatsd/" style="font-size: 10px;">gnatsd</a> <a href="/blog/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/blog/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/blog/tags/masonry/" style="font-size: 10px;">masonry</a> <a href="/blog/tags/navigation/" style="font-size: 10px;">navigation</a> <a href="/blog/tags/swift/" style="font-size: 10px;">swift</a> <a href="/blog/tags/tabbar/" style="font-size: 10px;">tabbar</a> <a href="/blog/tags/xml/" style="font-size: 10px;">xml</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">C Z</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://images.libcz.com:8000/images/white_bg_logo.png" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">C Z</h1>
			</hgroup>
			
			<p class="header-subtitle">双能卫</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
					<li><a href="http://www.libcz.com/about.html">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="jianshu_ios" target="_blank" href="http://www.jianshu.com/users/b8b64af5b6f9/timeline" title="jianshu_ios">jianshu_ios</a>
			        
						<a class="github" target="_blank" href="http://github.com/cz-it" title="github">github</a>
			        
						<a class="jianshu_golang" target="_blank" href="http://www.jianshu.com/users/86f2f6a5968e/timeline" title="jianshu_golang">jianshu_golang</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-iOS/autolayout/masonry/have_a_try_with_masonry" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/05/03/iOS/autolayout/masonry/have_a_try_with_masonry/" class="article-date">
  	<time datetime="2016-05-02T16:00:00.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/05/03/iOS/autolayout/masonry/have_a_try_with_masonry/">活用Masonry</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>Masonry is still actively maintained, we are committed to fixing bugs and merging good quality PRs from the wider community. However if you’re using Swift in your project, we recommend using SnapKit as it provides better type safety with a simpler API.<br>– <a href="https://github.com/SnapKit/Masonry">https://github.com/SnapKit/Masonry</a></p>
</blockquote>
<p>首先来段免责声明，Masonry现在虽然任在维护中，但是官方现在的精力在其Swift版本的<a href="https://github.com/SnapKit/SnapKit">SnapKit</a>。</p>
<p>Masonry提供了一种链式（chainable）描述AutoLayout的DSL(Domain Specific Language)。何为链式呢？比如</p>
<pre><code>xiaoming.goToScholl().and.playBasketball()
</code></pre><p>类似这样，用“.”将各个词语连接起来达成一项功能的时候，这样使得表达式（DSL）更接近自然语言。上面的语句字面意思是不是就是”小明去学校打篮球去了”，会几个英语单词的小学生基本都能读懂。如果真如Masonry自己描述的一样，他用这样一个“chainable”的DSL是否能够消除AutoLayout的复杂和冗余呢？<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/autolayout/">autolayout</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/iOS/">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/masonry/">masonry</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/iOS/">iOS</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/blog/2016/05/03/iOS/autolayout/masonry/have_a_try_with_masonry/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-golang/nats/have_a_try_with_gnatcd" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/04/10/golang/nats/have_a_try_with_gnatcd/" class="article-date">
  	<time datetime="2016-04-09T16:00:00.000Z" itemprop="datePublished">2016-04-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/04/10/golang/nats/have_a_try_with_gnatcd/">NATS之gnatcd初体验</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>现在Message Queue有多种选择，比如Java的Kafaka/ActiveMQ、Erlang的RabbitMQ、Golang的NSQ以及这里要说的gnatcd。</p>
<h2 id="1-NATS与gnatcd"><a href="#1-NATS与gnatcd" class="headerlink" title="1. NATS与gnatcd"></a>1. NATS与gnatcd</h2><blockquote>
<p>NATS is Open Source. Performant. Simple. Scalable.A central nervous system for modern, reliable and scalable cloud and distributed systems.<br>                                                 –<a href="http://nats.io/">http://nats.io/</a></p>
</blockquote>
<p>按照其官网的说法，NATS是一个开源的、高性能的、简洁的、灵活的 适用于现代的可靠灵活的云和分布式系统的中枢系统。 说的很玄乎，实际上就是一个分布式<br>的消息队列系统，支持PubSub/ReqRsp 模型。其最初由Apcera领导开发，并实现了Ruby版本的服务器和客户端，其主要作者<a href="https://github.com/derekcollison">Derek Collison</a>自称做了20多年的MQ，并经历过TIBOC、Rendezvous、EMC公司，这里有<a href="https://www.reddit.com/r/golang/comments/1oqqx7/gnatsd_from_apcera_a_high_performance_nats_server/">他自己的reddit回答</a>。</p>
<p>根据<a href="https://github.com/nats-io">github</a>里面<a href="https://github.com/nats-io/ruby-nats">ruby-nats</a>的日志显示在11年Derek实现了Ruby版本<br>的NATS服务器以及对应的客户端。然后在12年末，Derek又用Golang将服务器重写了一遍，并最终发现其效果更好，于是现在慢慢将Ruby版本的服务器淘汰了，现在<br>官网也只维护一个Golang版本的服务器，也就是我们这里的gnatcd。</p>
<blockquote>
<p>NATS provides a lightweight server that is written in the Go programming language. Apcera actively maintains and supports the NATS server source code, binary distributions, and Docker image.<br>                                            – <a href="http://nats.io/documentation/">http://nats.io/documentation/</a></p>
</blockquote>
<p>gnatcd根据NATS说法，会由Apcera维护，并提供源码、二进制文件以及Docker镜像文件。</p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/NATS/">NATS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/gnatsd/">gnatsd</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/golang/">golang</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/golang/">golang</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/blog/2016/04/10/golang/nats/have_a_try_with_gnatcd/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-golang/grpc/have_a_try_on_grpc" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/03/10/golang/grpc/have_a_try_on_grpc/" class="article-date">
  	<time datetime="2016-03-09T16:00:00.000Z" itemprop="datePublished">2016-03-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/10/golang/grpc/have_a_try_on_grpc/">gRPC初体验</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>gRPC是由Google主导开发的RPC框架，使用HTTP/2协议并用ProtoBuf作为序列化工具。其客户端提供Objective-C、Java接口，服务器侧则有Java、Golang、C++等接口，从而为移动端（iOS/Androi）到服务器端通讯提供了一种解决方案。 当然在当下的环境下，这种解决方案更热门的方式是RESTFull API接口。该方式需要自己去选择编码方式、服务器架构、自己搭建框架（JSON-RPC）。gRPC官方对REST的声音是：</p>
<ul>
<li>和REST一样遵循HTTP协议(明确的说是HTTP/2)，但是gRPC提供了全双工流</li>
<li>和传统的REST不同的是gRPC使用了静态路径，从而提高性能</li>
<li>用一些格式化的错误码代替了HTTP的状态码更好的标示错误</li>
</ul>
<p>至于是否要选择用gRPC。对于已经有一套方案的团队，可以参考下。如果是从头来做，可以考虑下gRPC提供的从客户端到服务器的整套解决方案，这样不用客户端去实现http的请求会话，JSON等的解析，服务器端也有现成的框架用。从15年3月到现在gRPC也发展了一年了，慢慢趋于成熟。下面我们就以gRPC的Golang版本看下其在golang上面的表现。至于服务端的RPC，感觉golang标准库的RPC框架基本够用了,没必要再去用另一套方案。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/gRPC/">gRPC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/golang/">golang</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/golang/">golang</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/blog/2016/03/10/golang/grpc/have_a_try_on_grpc/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS/encoding/json/nsjsonserialization/json_with_nsjsonserialization" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/03/09/iOS/encoding/json/nsjsonserialization/json_with_nsjsonserialization/" class="article-date">
  	<time datetime="2016-03-08T16:00:00.000Z" itemprop="datePublished">2016-03-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/09/iOS/encoding/json/nsjsonserialization/json_with_nsjsonserialization/">用NSJSONSerialization让JSON变服帖</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前的文章<a href="http://www.libcz.com/blog/2016/03/08/iOS/xml/Ono/use_ono_to_read_xml/#more">使用Ono读取XML文件</a>/<a href="http://www.jianshu.com/p/92d8d109bfc8">简书</a>介绍了如何处理XML数据，随着Web时代的ajax的盛行，在App时代，另一个最常需要处理的的数据就是JSON数据，尤其现在的Restful背景下API数据的传递，更有胜者直接就是JSON RPC。此时既要读取解析JSON也要为数据结构生成对应的JSON数据。在以前，iOS/Mac平台有多钟JSON解决方案，如SBJSON、TouchJSON、YAJL、JSONKit，当然还有C里面的cJSON/RapidJSON可以进行封装，效率和正确率也是刚刚的。Apple自家也提供了一套解决方案：NSJSONSerialization，这个NSJSONSerialization比他们自家的XML解析工具NSXMLParser可好多了，他既有可人的接口，又提供了非凡的效率（有<a href="http://arthurchen.blog.51cto.com/2483760/723910">测评表明比SBJSON/JSONKit等强</a>），并且是Apple系统提供的正规军，因此首推这个方案。</p>
<p>NSJSONSerialization提供的接口非常简单，甚至于<a href="https://developer.apple.com/library/ios/documentation/Foundation/Reference/NSJSONSerialization_Class/index.html">官网的Manual</a>只有少量的文字描述。</p>
<blockquote>
<p>You use the NSJSONSerialization class to convert JSON to Foundation objects and convert Foundation objects to JSON</p>
</blockquote>
<p>可见，NSJSONSerialization是可以直接将JSON数据转换成Foundation中提供的对象如NSArray、NSDictionary、NSString、NSNumber等；也可以直接把这些Foundation的对象转换成JSON数据，这一看就是个超人性的接口。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/JSON/">JSON</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/NSJSONSerialization/">NSJSONSerialization</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/iOS/">iOS</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/blog/2016/03/09/iOS/encoding/json/nsjsonserialization/json_with_nsjsonserialization/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS/encoding/xml/Ono/use_ono_to_read_xml" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/03/04/iOS/encoding/xml/Ono/use_ono_to_read_xml/" class="article-date">
  	<time datetime="2016-03-03T16:00:00.000Z" itemprop="datePublished">2016-03-04</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016/03/04/iOS/encoding/xml/Ono/use_ono_to_read_xml/">使用Ono读取XML文件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在做App的过程中，读取XML文件是最常见的功能之一。并且在iOS的发展过程中涌现出了多种XML的解决方案。如Apple自家提供的NSXMLParser和libxml2(C接口).另外还有大量第三方库工具如TBXML、TouchXML、KissXML、TinyXML。在<a href="https://www.raywenderlich.com/553/xml-tutorial-for-ios-how-to-choose-the-best-xml-parser-for-your-iphone-project">raywenderlich上面有个详细的对比</a>，他的对比结论是：</p>
<ul>
<li>如果仅仅是解析比较小的XML数据，可以考虑NSXMLParser、TouchXML、KissXML或者GDataXML ，理由是简单好用</li>
<li>如果是解析比较大数据的XML，则推荐 libxml2(SAX模式)或者 TBXML。性能较好，但是使用复杂</li>
</ul>
<blockquote>
<p>解析XML通常有两种方式：DOM和SAX</p>
<p>DOM解析XML时，读入整个XML文档并构建一个驻留内存的树结构（称“节点树”），之后就通过遍历树结构可以检索任意XML节点，读取它的属性和值。而起通常情况下，可以借助XPath，直接查询XML节点。<br>SAX解析XML，是基于事件通知的模式，一边读取XML文档一边处理，不必等整个文档加载完之后才采取操作，当在读取解析过程中遇到需要处理的对象，会发出通知对其进行处理。</p>
</blockquote>
<p>从上面来看，后两者可以满足各种场景，只是使用上面偏向复杂，尤其是libxml2还是C接口。而今天我们要介绍的是Ono就是对这个C接口的libxml2的一层OC友好接口的封装，这个接口是谁设计的呢？靠谱么？<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Ono/">Ono</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/xml/">xml</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/iOS/">iOS</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/blog/2016/03/04/iOS/encoding/xml/Ono/use_ono_to_read_xml/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS/develop_app_with_swift/TabBar/an_app_with_tabbar" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2015/05/17/iOS/develop_app_with_swift/TabBar/an_app_with_tabbar/" class="article-date">
  	<time datetime="2015-05-16T16:00:00.000Z" itemprop="datePublished">2015-05-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/05/17/iOS/develop_app_with_swift/TabBar/an_app_with_tabbar/">另一张TabBar大众脸的App</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前面我们通过Navigation创建了一种可以切换界面外壳的App，其实拿起iPhone，我们发现除了这种类型还有另一种类型外壳的App.如下图：</p>
<p><img src="http://images.libcz.com:8000/images/blog/iOS/develop_app_with_swift/TabBar/alarm.png" alt="alarm"> <img src="http://images.libcz.com:8000/images/blog/iOS/develop_app_with_swift/TabBar/appstore.png" alt="appstore"></p>
<p>我们发现这类App都是在最下面有一排Tab，每个Tab的Item表示一个分类的界面，通过点击这些Tab可以切换到对应的界面中。再回想下QQ/微信、<br>淘宝/天猫、微博等每天都要用的App。</p>
<p>发现了什么？？？这些App都是这样的一个基本外壳。是不是把这个学会了，就是做牛逼哄哄的App了？<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/tabbar/">tabbar</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/iOS/">iOS</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/blog/2015/05/17/iOS/develop_app_with_swift/TabBar/an_app_with_tabbar/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-iOS/develop_app_with_swift/Navigation/an_app_with_navigation" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2015/05/11/iOS/develop_app_with_swift/Navigation/an_app_with_navigation/" class="article-date">
  	<time datetime="2015-05-10T16:00:00.000Z" itemprop="datePublished">2015-05-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2015/05/11/iOS/develop_app_with_swift/Navigation/an_app_with_navigation/">通过Navigation创建一张大众脸的App</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>拿出iPhone。随手点开几个系统应用，比如“信息”，我们会看到如下的界面结构：</p>
<p><img src="http://images.libcz.com:8000/images/blog/iOS/develop_app_with_swift/Navigation/message_01.png" alt="message_01"> <img src="http://images.libcz.com:8000/images/blog/iOS/develop_app_with_swift/Navigation/message_02.png" alt="message_02"></p>
<p>或者点开“设置”也会发现他是有个首部的标题栏加上“Body”部分内容，然后再内容中点击后会跳转到子界面，并且在子界面中保留了首部，同时首部会有“返回”字样的按钮可以会<br>到上一层界面中。</p>
<p>这样的一个界面结构在App中比较常见，可谓是一张“大众脸”。<br>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/navigation/">navigation</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/blog/categories/iOS/">iOS</a>
	</div>


      
        <p class="article-more-link">
          <a  href="/blog/2015/05/11/iOS/develop_app_with_swift/Navigation/an_app_with_navigation/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/blog/">&laquo; Prev</a><a class="page-number" href="/blog/">1</a><span class="page-number current">2</span><a class="page-number" href="/blog/page/3/">3</a><a class="extend next" rel="next" href="/blog/page/3/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <p><a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/"><img alt="知识共享许可协议" style="border-width:0" src="https://i.creativecommons.org/l/by-nd/4.0/88x31.png" /></a><br />本站采用<a rel="license" href="http://creativecommons.org/licenses/by-nd/4.0/">知识共享Attribution-NoDerivatives 4.0 国际许可协议</a>进行许可。</p>
    	<div class="footer-left">
    		&copy; 2016 C Z
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>

    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/blog/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>